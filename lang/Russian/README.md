Скачать
------------
Загрузки можно найти [здесь] (https://github.com/HatcherMine/Raptoreum-Miner/releases)

Требования
------------

1. CPU с архитектурой x86-64 с минимальной поддержкой SSE2. Это включает
Intel Core2 или новее и эквиваленты AMD. Доступны дальнейшие оптимизации
на некоторых алгоритмах для процессоров с AES, AVX, AVX2, SHA, AVX512 и VAES.

Процессоры ARM и Aarch64 пока не поддерживаются.

2. 64-битная ОС Linux или Windows. Известно, что дистрибутивы на основе Ubuntu и Fedora, включая Mint и Centos, работают и имеют все зависимости в своих репозиториях. Другие могут работать, но могут потребовать дополнительных усилий. Старые версии, такие как Centos 6, не работают из-за отсутствия функций. 64-разрядная версия Windows поддерживается mingw-w64 и msys или предварительно созданными двоичными файлами.

MacOS, OSx и Android не поддерживаются.

3. Пул уровней, поддерживающих протоколы stratum + tcp: // или stratum + ssl: //, или RPC getwork с использованием http: // или https: // .GBT - это YMMV.

Поддерживаемые алгоритмы
--------------------


                          gr Призрачный гонщик (RTM)
                           

Быстрая установка
-----------

      Чтобы добавить или использовать параметры майнера, используйте прилагаемый файл config.json.
      Все параметры должны быть в формате JSON, например:
      "long-flag-name": "Some_value"

      Некоторые примеры:
      полная мелодия: правда
      "tune-config": "имя файла"
      "url": "stratum + tcp: // YOUR_POOL_ADDRESS: PORT"
      "пользователь": "ВАШ_КОШЕЛЬК"

Полный список опций майнера и другие советы можно найти в файле readme.txt.

Тюнинг
------
Установка запускается автоматически при запуске майнера. Если предыдущий файл настройки tune_config существует (или используется флаг --tune-config = FILE), он используется вместо него. Это поведение можно изменить с помощью --no-tune или --force-tune. На процессорах, отличных от AVX2, процесс установки по умолчанию занимает ~ 69 минут. На процессоре AVX2 процесс установки по умолчанию занимает ~ 155 минут.


Небольшое объяснение того, что делает тюнинг. Традиционный способ хеширования: взять некоторый ввод, хешировать его, чтобы сгенерировать выходной хеш. Это то, что можно было бы назвать обычным хешированием (также известным как 1way), поскольку мы выполняем 1 хеш за раз. Что мы можем делать хешировать 2 или 4 хеша одновременно! Из-за различных параметров, используемых в каждом блоке, и т. Д., Требования к памяти меняются, и мы хотели бы иметь как можно больше ее в кеше, поскольку ОЗУ МЕДЛЕННО! Таким образом, 1way потребуется 128 КБ, 256 КБ, 256 КБ, 512 КБ, 1 МБ или 2 МБ для хранения где-нибудь, если мы хотим решить эту проблему. 2 варианта возьмут в 2 раза больше этой суммы, а 4 варианта - 4 раза. В некоторых случаях, например, для вариантов с 256 КБ, это увеличивает требования до 1 МБ или 2 МБ для вариантов с 512 КБ. В большинстве случаев такой объем данных может поместиться в кэш, что может повысить производительность. Слишком много может уменьшить его, представьте 8 МБ для 4way Fast (вариант 2 МБ) (это все еще самый быстрый в некоторых случаях, если вашему процессору не хватает кеша, такого как i3 или некоторые мобильные процессоры). Итак, есть 6 вариантов сделать 20 возможных «вращений». И мы тестируем все эти 20 поворотов, чтобы убедиться, что использование 1-ходового, 2-ходового или 4-ходового хода на каждом из них приносит улучшение или нет. Мы не можем проверить это индивидуально, когда они хешируют их все, это может быть больше неточным, поэтому у нас есть 8 сценариев на ротацию для AVX (только 1 вариант или 2 варианта, 2 ^ 3, 2 способа решения для 3 вариантов) и 27 для AVX2 (1way, 2way, 4way, 3 ^ 3, 3 способа для 3 вариантов) -> this --tune-full проверяет все это. --tune-simple тестирует только 4way против вариантов Turtle и Turtlelite и по умолчанию также проверяет Dark и Darklite, поскольку они, скорее всего, будут использоваться процессорами или извлекать выгоду из них во всех наших тестах. Таким образом, мы можем использовать большую часть кеша и использовать его с максимальной эффективностью. Вы можете спросить, почему 2way быстрее, чем 1way в 2 раза? Это потому, что мы можем использовать еще несколько способов распараллеливания и других уловок, чтобы уведомить ЦП о том, что произойдет, чтобы он мог быстрее подготовить данные.
