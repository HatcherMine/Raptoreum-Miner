Скачать
------------
Загрузки можно найти [здесь](https://github.com/HatcherMine/Raptoreum-Miner/releases)

Требования
------------

1. CPU с архитектурой x86-64 с минимальной поддержкой SSE2. Это включает
Intel Core2 или новее и эквиваленты AMD. Доступны дальнейшие оптимизации
на некоторых алгоритмах для процессоров с AES, AVX, AVX2, SHA, AVX512 и VAES.

Процессоры ARM и Aarch64 пока не поддерживаются.

2. 64-битная ОС Linux или Windows. Известно, что дистрибутивы на основе Ubuntu и Fedora, включая Mint и Centos, работают и имеют все зависимости в своих репозиториях. Другие могут работать, но могут потребовать дополнительных усилий. Старые версии, такие как Centos 6, не работают из-за отсутствия функций. 64-разрядная версия Windows поддерживается mingw-w64 и msys или предварительно созданными двоичными файлами.

MacOS, OSx и Android не поддерживаются.

3. Пул уровней, поддерживающих протоколы stratum + tcp: // или stratum + ssl: //, или RPC getwork с использованием http: // или https: // .GBT - это YMMV.

Поддерживаемые алгоритмы
--------------------


                          gr Призрачный гонщик (RTM)
                           

Быстрая установка
-----------

      Чтобы добавить или использовать параметры майнера, используйте прилагаемый файл config.json.
      Все параметры должны быть в формате JSON, например:
      "long-flag-name": "Some_value"

      Некоторые примеры:
      полная мелодия: правда
      "tune-config": "имя файла"
      "url": "stratum + tcp: // YOUR_POOL_ADDRESS: PORT"
      "пользователь": "ВАШ_КОШЕЛЬК"

Полный список опций майнера и другие советы можно найти в файле readme.txt.

Тюнинг
------
Установка запускается автоматически при запуске майнера. Если предыдущий файл настройки tune_config существует (или используется флаг --tune-config = FILE), он используется вместо него. Это поведение можно изменить с помощью --no-tune или --force-tune. На процессорах, отличных от AVX2, процесс установки по умолчанию занимает ~ 69 минут. На процессоре AVX2 процесс установки по умолчанию занимает ~ 155 минут.


Небольшое объяснение того, что делает тюнинг. Традиционный способ хеширования: взять некоторый ввод, хешировать его, чтобы сгенерировать выходной хеш. Это то, что можно было бы назвать обычным хешированием (также известным как 1way), поскольку мы выполняем 1 хеш за раз. Что мы можем делать хешировать 2 или 4 хеша одновременно! Из-за различных параметров, используемых в каждом блоке, и т. Д., Требования к памяти меняются, и мы хотели бы иметь как можно больше ее в кеше, поскольку ОЗУ МЕДЛЕННО! Таким образом, 1way потребуется 128 КБ, 256 КБ, 256 КБ, 512 КБ, 1 МБ или 2 МБ для хранения где-нибудь, если мы хотим решить эту проблему. 2 варианта возьмут в 2 раза больше этой суммы, а 4 варианта - 4 раза. В некоторых случаях, например, для вариантов с 256 КБ, это увеличивает требования до 1 МБ или 2 МБ для вариантов с 512 КБ. В большинстве случаев такой объем данных может поместиться в кэш, что может повысить производительность. Слишком много может уменьшить его, представьте 8 МБ для 4way Fast (вариант 2 МБ) (это все еще самый быстрый в некоторых случаях, если вашему процессору не хватает кеша, такого как i3 или некоторые мобильные процессоры). Итак, есть 6 вариантов сделать 20 возможных «вращений». И мы тестируем все эти 20 поворотов, чтобы убедиться, что использование 1-ходового, 2-ходового или 4-ходового хода на каждом из них приносит улучшение или нет. Мы не можем проверить это индивидуально, когда они хешируют их все, это может быть больше неточным, поэтому у нас есть 8 сценариев на ротацию для AVX (только 1 вариант или 2 варианта, 2 ^ 3, 2 способа решения для 3 вариантов) и 27 для AVX2 (1way, 2way, 4way, 3 ^ 3, 3 способа для 3 вариантов) -> this --tune-full проверяет все это. --tune-simple тестирует только 4way против вариантов Turtle и Turtlelite и по умолчанию также проверяет Dark и Darklite, поскольку они, скорее всего, будут использоваться процессорами или извлекать выгоду из них во всех наших тестах. Таким образом, мы можем использовать большую часть кеша и использовать его с максимальной эффективностью. Вы можете спросить, почему 2way быстрее, чем 1way в 2 раза? Это потому, что мы можем использовать еще несколько способов распараллеливания и других уловок, чтобы уведомить ЦП о том, что произойдет, чтобы он мог быстрее подготовить данные.

Призрачный гонщик (GR)
---------------

Алгоритм Ghost Rider (GR), который используется для майнинга RTM, состоит из 15 "ядер" алгоритмы (такие же, как в X16 без SHA) и 6 различных вариантов Cryptonight из которых только 3 используются для хеширования. Каждый блок (в части предыдущего блока в реальность) диктует, в каком порядке должны вычисляться эти алгоритмы, и какой из вариантов Cryptonight следует использовать. Это выглядит так:
5 основных алгоритмов, 1 Cryptonight, 5 ядер, 1 Cryptonight, 5 ядер, 1 Cryptonight.
Как видите, всегда используются все основные алгоритмы, но только 3 из 6 вариантов. Криптонайт. Эти части Cryptonight - самая медленная / самая сложная часть весь процесс хеширования. Основные алгоритмы очень хорошо работают практически на всех CPU, но Cryptonight требует определенного количества памяти, если эта память может быть полностью или в основном хранится в кеше, что увеличивает производительность значительно (основная причина, по которой AMD Ryzens намного быстрее, чем Intel, поскольку у них намного больше L3 Cache). Варианты CN используют 128 КБ, 256 КБ, 256 КБ, 512 КБ, 1 МБ или 2 МБ или памяти. Кроме того, чем больше объем памяти необходимо, тем больше итераций через него (что делает егоеще медленнее :P). В производительность этих алгоритмов может сильно различаться. Вы могли бы стать похожими на 1500 H/s, если блокам нужны 3 самых медленных варианта (те, которые используют большую часть памяти) и 10000+ H/s, если блоки используют самые быстрые (на примере моего 2x2698v3). Это означает 2 вещи. Во-первых, скорость хеширования, как вы заметили, очень нестабильна и меняется почти всегда с каждым блоком. Майнер должен показать вам Cryptonight варианты, используемые в текущем блоке, Turtlelite, Turtle, Darklite, Dark, Lite, Fast - это варианты в том же порядке, в котором я упоминал память, ирония в том, что Быстрый вариант - самый медленный, а Turtlelite - самый быстрый :). Во-вторых, некоторые блоки (в большинстве случаев  е, которые используют более простые варианты) обнаруживаются быстрее, а не очень последовательно. Все должно составлять в среднем около 120 секунд на блок, хотя в долгосрочной перспективе.
